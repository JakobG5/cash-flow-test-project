// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: balances.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createMerchantBalance = `-- name: CreateMerchantBalance :one
INSERT INTO merchant_balances (merchant_id, currency)
VALUES ($1, $2)
RETURNING id, merchant_id, currency, available_balance, pending_balance, total_processed, last_updated
`

type CreateMerchantBalanceParams struct {
	MerchantID uuid.UUID    `db:"merchant_id" json:"merchant_id"`
	Currency   CurrencyType `db:"currency" json:"currency"`
}

func (q *Queries) CreateMerchantBalance(ctx context.Context, arg *CreateMerchantBalanceParams) (*MerchantBalance, error) {
	row := q.db.QueryRowContext(ctx, createMerchantBalance, arg.MerchantID, arg.Currency)
	var i MerchantBalance
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Currency,
		&i.AvailableBalance,
		&i.PendingBalance,
		&i.TotalProcessed,
		&i.LastUpdated,
	)
	return &i, err
}

const getMerchantBalance = `-- name: GetMerchantBalance :one
SELECT id, merchant_id, currency, available_balance, pending_balance, total_processed, last_updated
FROM merchant_balances
WHERE merchant_id = $1 AND currency = $2
`

type GetMerchantBalanceParams struct {
	MerchantID uuid.UUID    `db:"merchant_id" json:"merchant_id"`
	Currency   CurrencyType `db:"currency" json:"currency"`
}

func (q *Queries) GetMerchantBalance(ctx context.Context, arg *GetMerchantBalanceParams) (*MerchantBalance, error) {
	row := q.db.QueryRowContext(ctx, getMerchantBalance, arg.MerchantID, arg.Currency)
	var i MerchantBalance
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Currency,
		&i.AvailableBalance,
		&i.PendingBalance,
		&i.TotalProcessed,
		&i.LastUpdated,
	)
	return &i, err
}

const getMerchantBalances = `-- name: GetMerchantBalances :many
SELECT id, merchant_id, currency, available_balance, pending_balance, total_processed, last_updated
FROM merchant_balances
WHERE merchant_id = $1
`

func (q *Queries) GetMerchantBalances(ctx context.Context, merchantID uuid.UUID) ([]*MerchantBalance, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantBalances, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*MerchantBalance{}
	for rows.Next() {
		var i MerchantBalance
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Currency,
			&i.AvailableBalance,
			&i.PendingBalance,
			&i.TotalProcessed,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMerchantBalance = `-- name: UpdateMerchantBalance :one
UPDATE merchant_balances
SET available_balance = $3, pending_balance = $4, total_processed = $5, last_updated = NOW()
WHERE merchant_id = $1 AND currency = $2
RETURNING id, merchant_id, currency, available_balance, pending_balance, total_processed, last_updated
`

type UpdateMerchantBalanceParams struct {
	MerchantID       uuid.UUID      `db:"merchant_id" json:"merchant_id"`
	Currency         CurrencyType   `db:"currency" json:"currency"`
	AvailableBalance sql.NullString `db:"available_balance" json:"available_balance"`
	PendingBalance   sql.NullString `db:"pending_balance" json:"pending_balance"`
	TotalProcessed   sql.NullString `db:"total_processed" json:"total_processed"`
}

func (q *Queries) UpdateMerchantBalance(ctx context.Context, arg *UpdateMerchantBalanceParams) (*MerchantBalance, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantBalance,
		arg.MerchantID,
		arg.Currency,
		arg.AvailableBalance,
		arg.PendingBalance,
		arg.TotalProcessed,
	)
	var i MerchantBalance
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Currency,
		&i.AvailableBalance,
		&i.PendingBalance,
		&i.TotalProcessed,
		&i.LastUpdated,
	)
	return &i, err
}
